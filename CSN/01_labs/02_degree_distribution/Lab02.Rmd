---
title: "Complex & Social Networks: Lab 02 Report"
author:
  - Francisco Javier Jurado Moreno
  - Sergio Mosquera Dopico
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction

#Results

#Discussion

#Methods

```{r cars, include=FALSE}
# Load the igraph library and require the packages stats4 (mle) & VGAM (Riemman-zeta)
require(igraph)
require(knitr)
require('stats4')
require('VGAM')
require(kableExtra)
```

```{r, include=FALSE}
# Read the list of languages from file
languages = read.table("list.txt",
              header = TRUE,               # this is to indicate the first line of the file contains the names of the columns instead of the real data
              as.is = c("language","file") # this is need to have the cells treated as real strings and not as categorial data.
            )

# Read the language files from disk and store them in memory so we don't have to do so multiple times
in_degree_sequences <- vector('list', nrow(languages))
for (i in seq(from=1, to=nrow(languages))){
  in_degree_sequences[i] <- read.table(languages$file[i], header = FALSE)
}
```

Print the first table

```{r, include=FALSE}
# Function to write the languages summary (Table 1) from the already-read language data
language_summary <- function(in_degree_sequence) {
  # Generate the summary for a given language (corresponding to a row of table 1 minus the language's name)
  # Returns a vector with the following values:
   # | language | num nodes | max degree | mean degree | inv mean degree |
  c(length(in_degree_sequence),
      max(in_degree_sequence),
       sum(in_degree_sequence)/length(in_degree_sequence),
       length(in_degree_sequence)/sum(in_degree_sequence))
}
```

```{r, echo=FALSE}
# Apply generate_language_summary to every entry in the list of language in-degrees to generate the summary for every language. Use do.call to pass each summary to rbind as a parameter, that way the vectors are concatenated vertically
summary_df <- data.frame(do.call(rbind, lapply(in_degree_sequences, language_summary)), row.names=languages$language)

kable(summary_df, "latex", col.names=c('N', 'Max Degree', 'M/N', 'N/M'), booktabs=T, linesep='', align='c', digits=4) %>%
  kable_styling(latex_options = "striped", full_width=T)
```

```{r, echo=FALSE}
# Define the minus log likelihood functions for the different probaiblity mass functions to be passed to the optimizer
models <- c('Poisson', 'Geometric', 'Zeta_2', 'Zeta', 'Right-truncated Zeta')
minus_log_likelihoods <- c(
  # Displaced Poisson
  function (lambda) { N*(lambda + log(1 - exp(-lambda))) + C - M*log(lambda) },
  
  # Displaced Geometric
  function (q) {
    (N - M)*log(1-q) - N*log(q)
  },
  
  # Zeta with gamma=2
  function() {
    2*M_prime + N*log((pi^2)/6)
  },
  
  # Zeta
  function(gamma) {
     M_prime*gamma + N*log(zeta(gamma))
  },
  
  # Right-truncated Zeta
  function (gamma, k_max) {
    gamma*M_prime + N*log(sum(sapply(seq(from=1, to=k_max, by=1), function(x) x^(-gamma))))
  })

start_parameters <- c(
  function() { list( lambda=M/N ) },
  function() { list( q=N/M ) },
  function() { list( gamma=2 )},
  function() { list( gamma=2 )},
  function() { list( gamma=2 )}
)

```

```{r}
calculate_likelihoods <- function(in_degree_sequence) {
  N <<- length(in_degree_sequence)
  M <<- sum(in_degree_sequence)
  M_prime <<- sum(log(in_degree_sequence))
  C <<- sum(sapply(seq(from=1, to=N, by=1), function(i) sum(sapply(seq(from=1, to=in_degree_sequence[i], by=1), function(j) log(j)))))

  for (i in seq(from=1, to=length(models), by=1)) {
    mle(minus_log_likelihoods[[i]],
        start = start_parameters[[i]](),
                      method = "L-BFGS-B")
  }
}
#minus_log_likelihoods[[1]](0.5)
calculate_likelihoods(in_degree_sequences[[1]])
```

```{r}
list(lambda=M/N)
```

```{r}
length(models)
```

```{r, echo=FALSE}

parameters <- data.frame(matrix(ncol = 6, nrow = 0))
models <- data.frame(matrix(ncol = 6, nrow = 0))
colnames(parameters) <- c("Language", "lambda", "q", "zeta", "rtrunc_zeta", "k_max")
colnames(models) <- c("Language", "poisson", "geometric", "zeta_gamma_2", "zeta", "rtrunc_zeta")

for (l in seq(1, nrow(languages))) {
  x <- langs_in_degree[[l]]
  N <- length(x)
  M <- sum(x)
  M_prime <- sum(log(x))
  print(minus_log_likelihood_geometric(0.5))
  C <- sum(sapply(seq(from=1, to=N, by=1), function(i) sum(sapply(seq(from=1, to=x[i], by=1), function(j) log(j)))))

  mle_poisson <- mle(minus_log_likelihood_poisson,
                      start = list(lambda = M/N),
                      method = "L-BFGS-B",
                      lower = NA)

  #lambda <- attributes(summary(mle_poisson))$coef[1]

  mle_geometric <- mle(minus_log_likelihood_geometric,
                       start = list(q = N/M),
                       method = "L-BFGS-B",
                       lower = c(0.0000001),
                       upper = c(0.9999999)) # We needed to set an upper bound

  q <- attributes(summary(mle_geometric))$coef[1]

  mle_zeta_2 <- mle(minus_log_likelihood_zeta,
                  start = list(gamma = 2),
                  method = "L-BFGS-B",
                  lower = c(1.0000001))

  zeta <- attributes(summary(mle_zeta_2))$coef[1]
  
  
  mle_zeta <- mle(minus_log_likelihood_zeta,
                  start = list(gamma = zeta),
                  method = "L-BFGS-B",
                  lower = c(1.0000001))

  mle_rtrunc_zeta <- mle(minus_log_likelihood_rtrunc_zeta,
                  start = list(gamma = 2, k_max = max(x)), #We've chosen the largest k
                  method = "L-BFGS-B") #

  rtrunc_zeta <- attributes(summary(mle_rtrunc_zeta))$coef[1]
  k_max <- attributes(summary(mle_rtrunc_zeta))$coef[2]

  parameters[nrow(parameters) + 1,] = c(languages$language[[l]],
                                        lambda,
                                        q,
                                        zeta,
                                        rtrunc_zeta,
                                        k_max)
  models[nrow(models) + 1,] = c(languages$language[[l]],
                                    attributes(summary(mle_poisson))$m2logL,
                                    attributes(summary(mle_geometric))$m2logL,
                                    attributes(summary(mle_zeta_2))$m2logL,
                                    attributes(summary(mle_zeta))$m2logL,
                                    attributes(summary(mle_rtrunc_zeta))$m2logL)
}
```

```{r, echo=FALSE}
# Function to write the languages summary (Table 2) from the data retrieved in previous chunk
write_summary_2 <- function(row) {
   # Generate the language summary (corresponding to a table row) by concatenating the following fields (Language name must be accessed)
   # | Language | lambda | q | zeta | right_truncated_zeta | k_max |
   cat(row$Language,
       row$lambda,
       row$q,
       row$zeta,
       row$rtrunc_zeta,
       row$k_max,
       "\n")
}
```

```{r, echo=FALSE}
for (i in seq(from=1, to=nrow(parameters))){
  write_summary_2(parameters[i,])
}
kable(parameters, "latex", col.names=colnames(parameters), booktabs=T, linesep='', align='c', digits=4) %>%
  kable_styling(latex_options = "striped", full_width=T)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
get_AIC <- function(m2logL, K, N){
  m2logL + 2*K*N/(N-K-1)
}
```

```{r}
# Function to write the languages summary (Table 2) from the data retrieved in previous chunk
write_summary_3 <- function(row, index) {
   # Generate the language summary (corresponding to a table row) by concatenating the following fields (Language name must be accessed)
   # | Language | poisson | geometric | zeta | right_truncated_zeta |
  k_used <- as.numeric(parameters$k_max[index])
  n_used <- length(row)
  cat(row$Language,
       get_AIC(as.numeric(row$poisson), k_used, n_used),
       get_AIC(as.numeric(row$geometric), k_used, n_used),
       get_AIC(as.numeric(row$zeta_gamma_2), k_used, n_used),
       get_AIC(as.numeric(row$zeta), k_used, n_used),
       get_AIC(as.numeric(row$rtrunc_zeta), k_used, n_used),
       "\n")
}
```

```{r}
for (i in seq(from=1, to=nrow(models))){
  write_summary_3(models[i,], i)
}
kable(models, "latex", col.names=colnames(models), booktabs=T, linesep='', align='c', digits=4) %>%
  kable_styling(latex_options = "striped", full_width=T)
```

