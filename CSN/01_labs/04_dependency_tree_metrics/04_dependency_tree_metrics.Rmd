---
title: "Lab 04 - Non-linear regression on dependency trees"
author: "Francisco Javier Jurado, Roger Pujol Torramorell"
date: "October 29, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
# Load and install necessary packages
requiredPackages <- c("knitr", "rstudioapi", "kableExtra", "stats")

for (pac in requiredPackages) {
    if(!require(pac,  character.only=TRUE)){
        install.packages(pac, repos="http://cran.rstudio.com")
        library(pac,  character.only=TRUE)
    }
}
rm(pac)
rm(requiredPackages)

# set pwd to current directory, must load rstudioapi before.
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

% Possible solutions for heteroscedasticity: work on smoothed versions of the data: eg. average all points for a value x and work on that

% plot everything to be plotted
% Check soundness by generating perfect synthetic data and checking the fit against it. R doesnt like perfect function, some error must be added to the actual data

% replace d with a z score transformation of d
% This transform could help to reduce noise in te data

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r echo=FALSE}
  # Read the list of languages from file
filename_suffix <- "_dependency_tree_metrics.txt"
language_list <- as.vector(read.table("data/language_list.txt", header = FALSE)$V1)

# Push the in-degree sequences and theh list of entries to the global scope
dep_tree_cols <- c('n', 'k^2', 'd')
dep_tree_metric_seqs <- lapply(language_list, function(x) data.frame(read.table(paste("data/", x, filename_suffix, sep=''), header = FALSE, col.names=dep_tree_cols)))
```

```{r, echo=FALSE}
summary_cols <- c('N', 'mean_n', 'sd_n', 'mean_d', 'sd_d')
metric_stats <- lapply(dep_tree_metric_seqs, function(x) list(
                    N=length(x),
                    mean_n=mean(x$n),
                    sd_n=sd(x$n),
                    mean_d=mean(x$d),
                    sd_d=sd(x$d)))

summary_df <- data.frame(do.call(rbind, lapply(metric_stats, function(x) c(x$N, x$mean_n, x$sd_n, x$mean_d, x$sd_d))), row.names=language_list)
kable(summary_df, 'latex', col.names=summary_cols, booktabs=T, linesep='', align='c', digits=4) %>%
  kable_styling(latex_options="striped", full_width=F)
```

```{r, echo=FALSE}
valid_k.2 <- lapply(dep_tree_metric_seqs, function(x) (4-(6/x$n) <= x$k.2) & (x$k.2 <= x$n-1))
valid_d <- lapply(dep_tree_metric_seqs, function(x) (x$k.2*x$n/(8*(x$n-1)) + 1/2 <= x$d) & (x$d <= x$n-1))
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='# vertices',
       ylab='mean dependency length',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=log(dep_tree_metric_seqs[[i]]$n),
       y=log(dep_tree_metric_seqs[[i]]$d),
       main=language_list[[i]],
       #log='xy',
       xlab='log(# vertices)',
       ylab='log(mean dependency length)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='log(# vertices)',
       ylab='log(mean dependency length)',
       col='blue')
}
```
<<<<<<< HEAD

```{r, echo=FALSE}
mean_seqs <- lapply(dep_tree_metric_seqs, function(x) aggregate(x, list(x$n), mean))
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(mean_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(mean_seqs), by=1)) {
  plot(x=mean_seqs[[i]]$n,
       y=mean_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='# vertices',
       ylab='mean (d)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(mean_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(mean_seqs), by=1)) {
  plot(x=mean_seqs[[i]]$n,
       y=mean_seqs[[i]]$d,
       main=language_list[[i]],
       log='xy',
       xlab='# vertices',
       ylab='mean (d)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       log='xy',
       xlab='# vertices',
       ylab='mean dependency length',
       col='blue')

  lines(x=mean_seqs[[i]]$n,
        y=mean_seqs[[i]]$d,
        col="green")
  lines(x=mean_seqs[[i]]$n,
        y=(mean_seqs[[i]]$d+1)/3,
        col="red")
}
```

```{r, echo=FALSE}

# Model parameters list
params_ensemble <- list(
  c('b'),       # Model 1
  c('a', 'b'),  # Model 2
  c('a','c'),   # Model 3
  c('a')        # Model 4
)

# Model formulas list
formula_ensemble <- c(
  d~(n/2)^b,     # Model 1
  d~a*n^b,       # Model 2
  d~a*exp(c*n),  # Model 3
  d~a*log(n)     # Model 4
)

# Log transform of the model formulas list
log_formulas <- c (
  log(d)~log(n/2) + 0, # Model 1
  log(d)~log(n),   # Model 2
  log(d)~n,        # Model 3
  log(d)~1*log(log(n)) # Model 4
)
```

```{r, echo=FALSE}
# Outer loop to iterate over the sequences
initial_values <- lapply( dep_tree_metric_seqs, function(seq) {
  # Inner loop 1 to iterate over the formulas
  lapply( seq(from=1, to=length(log_formulas), by=1), function(i) {
    lm <- lm(log_formulas[[i]], seq)
    # Inner loop 2 to iterate over the parameters of each model
    structure(sapply( seq(from=1, to=length(params_ensemble[[i]]), by=1), function(j)
      # Check if the parameter corresponds to "a", if so reverse the log transform by exponentiating it
      if(params_ensemble[[i]][[j]] == 'a') exp(coef(lm)[[j]]) else coef(lm)[[j]]), names=params_ensemble[[i]])
  })
})
data.frame(do.call(rbind, initial_values))
```

```{r}
nl_models <- lapply( seq(from=1, to=length(dep_tree_metric_seqs), by=1), function(i) {
  lapply( seq(from=1, to=length(formula_ensemble), by=1), function(j) {
    nlm <- nls(
      formula=formula_ensemble[[j]],
      data=dep_tree_metric_seqs[[i]],
      start=initial_values[[i]][[j]],
      trace=FALSE
    )
  })
})
```
