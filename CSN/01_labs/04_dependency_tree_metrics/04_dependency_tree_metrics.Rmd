---
title: "Lab 04 - Non-linear regression on dependency trees"
author: "Francisco Javier Jurado, Roger Pujol Torramorell"
date: "October 29, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
# Load and install necessary packages
requiredPackages <- c("knitr", "rstudioapi", "kableExtra", "stats")

for (pac in requiredPackages) {
    if(!require(pac,  character.only=TRUE)){
        install.packages(pac, repos="http://cran.rstudio.com")
        library(pac,  character.only=TRUE)
    }
}
rm(pac)
rm(requiredPackages)

# set pwd to current directory, must load rstudioapi before.
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

% Possible solutions for heteroscedasticity: work on smoothed versions of the data: eg. average all points for a value x and work on that

% plot everything to be plotted
% Check soundness by generating perfect synthetic data and checking the fit against it. R doesnt like perfect function, some error must be added to the actual data

% replace d with a z score transformation of d
% This transform could help to reduce noise in te data

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r echo=FALSE}
  # Read the list of languages from file
filename_suffix <- "_dependency_tree_metrics.txt"
language_list <- as.vector(read.table("data/language_list.txt", header = FALSE)$V1)

# Push the in-degree sequences and theh list of entries to the global scope
dep_tree_cols <- c('n', 'k^2', 'd')
dep_tree_metric_seqs <- lapply(language_list, function(x) data.frame(read.table(paste("data/", x, filename_suffix, sep=''), header = FALSE, col.names=dep_tree_cols)))
```

```{r, echo=FALSE}
summary_cols <- c('N', 'mean_n', 'sd_n', 'mean_d', 'sd_d')
metric_stats <- lapply(dep_tree_metric_seqs, function(x) list(
                    N=length(x),
                    mean_n=mean(x$n),
                    sd_n=sd(x$n),
                    mean_d=mean(x$d),
                    sd_d=sd(x$d)))

summary_df <- data.frame(do.call(rbind, lapply(metric_stats, function(x) c(x$N, x$mean_n, x$sd_n, x$mean_d, x$sd_d))), row.names=language_list)
kable(summary_df, 'latex', col.names=summary_cols, booktabs=T, linesep='', align='c', digits=4) %>%
  kable_styling(latex_options="striped", full_width=F)
```

```{r, echo=FALSE}
valid_k.2 <- lapply(dep_tree_metric_seqs, function(x) (4-(6/x$n) <= x$k.2) & (x$k.2 <= x$n-1))
valid_d <- lapply(dep_tree_metric_seqs, function(x) (x$k.2*x$n/(8*(x$n-1)) + 1/2 <= x$d) & (x$d <= x$n-1))
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='# vertices',
       ylab='mean dependency length',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=log(dep_tree_metric_seqs[[i]]$n),
       y=log(dep_tree_metric_seqs[[i]]$d),
       main=language_list[[i]],
       #log='xy',
       xlab='log(# vertices)',
       ylab='log(mean dependency length)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='log(# vertices)',
       ylab='log(mean dependency length)',
       col='blue')
}
```

```{r, echo=FALSE}
mean_seqs <- lapply(dep_tree_metric_seqs, function(x) aggregate(x, list(x$n), mean))
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(mean_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(mean_seqs), by=1)) {
  plot(x=mean_seqs[[i]]$n,
       y=mean_seqs[[i]]$d,
       main=language_list[[i]],
       #log='xy',
       xlab='# vertices',
       ylab='mean (d)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(mean_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(mean_seqs), by=1)) {
  plot(x=mean_seqs[[i]]$n,
       y=mean_seqs[[i]]$d,
       main=language_list[[i]],
       log='xy',
       xlab='# vertices',
       ylab='mean (d)',
       col='blue')
}
```

```{r, echo=FALSE, fig.width=16, fig.height=18}
old.par <- par(mfrow=c(ceiling(length(dep_tree_metric_seqs)/3), 3))
par(mar=c(4,4,2,2))
for (i in seq(from=1, to=length(dep_tree_metric_seqs), by=1)) {
  plot(x=dep_tree_metric_seqs[[i]]$n,
       y=dep_tree_metric_seqs[[i]]$d,
       main=language_list[[i]],
       log='xy',
       xlab='# vertices',
       ylab='mean dependency length',
       col='blue')

  lines(x=mean_seqs[[i]]$n,
        y=mean_seqs[[i]]$d,
        col="green")
  lines(x=mean_seqs[[i]]$n,
        y=(mean_seqs[[i]]$d+1)/3,
        col="red")
}
```

```{r, echo=FALSE}

# Model parameters list
params_ensemble <- list(
  c('b'),       # Model 1
  c('a', 'b'),  # Model 2
  c('a','c'),   # Model 3
  c('a')        # Model 4
)

# Model formulas list
formula_ensemble <- c(
  d~(n/2)^b,     # Model 1
  d~a*n^b,       # Model 2
  d~a*exp(c*n),  # Model 3
  d~a*log(n)     # Model 4
)

# Log transform of the model formulas list
log_formulas <- c (
  log(d)~log(n/2) + 0, # Model 1
  log(d)~log(n),   # Model 2
  log(d)~n,        # Model 3
  log(d)~1*log(log(n)) # Model 4
)
```

```{r}
lapply(mapply(list, log_formulas, params_ensemble, SIMPLIFY = FALSE)[[1]]
```

```{r, echo=FALSE}
# Outer loop to iterate over the sequences
lapply(dep_tree_metric_seqs, function(seq) {
  # Inner loop 1 to iterate over the formulas
  coefficients <- lapply (seq(from=1, to=length(log_formulas), by=1), function(i)
    # Inner loop 2 to operate over the parameters
    lapply (seq(from=1, to=length(params_ensemble[[i]]), by=1), function(j)
    lapply(structure(coef(lm(log_formulas[[i]], seq)),function(x)
              names=params_ensemble[[i]]))
  initial_values <- sapply(coefficients, function (coef) 1, USE.NAMES=TRUE, simplify=FALSE)
  #initial_values <- lapply(seq(from=1, to=length(log_formulas), by=1), function (i)
  #  structure(coef(lm(log_formulas[[i]], seq)), names=params_ensemble[[i]])
  #)
  #lapply(initial_values, function(x) x["a"] = exp(x["a"]))
})

```

```{r, echo=FALSE}


gen_nlm <- function (frm, ds, initial_values) { nls(
  formula=d~frm,
  data=ds,
  start=initial_values,
  trace=TRUE
)}

gen_initial_values_lm <- function(frm, ds) { lm(
  log(d)
)}

model_ensemble <- function(ds) {
  c(
    # Model 1
    generate_nlm (ds, )
    function(ds, initial_values){ nls(
                  formula=d~a*n^b,
                  data=ds,
                  start=initial_values,
                  trace=TRUE
                  )},

    # Model 2
    function (q) { (stats$N - stats$M)*log(1-q) - stats$N*log(q) },

    # Zeta with gamma=2
    function(lambda){ (n/2)^hp$b },

    # Zeta
    function(gamma) { stats$M_prime*gamma + stats$N*log(zeta(gamma)) },

    # Right-truncated Zeta
    function(gamma, k_max){ gamma*stats$M_prime + stats$N*log(H(gamma, k_max)) },

    # Altmann function
    function(gamma, delta, k_max) { gamma*stats$M_prime + delta*stats$M - stats$N*log( c_f(gamma, delta, k_max ) ) }
  )
}
```
```{r}
dep_tree_metric_seqs[[1]]
```
```{r}
lin_model  <- (lm(log(d)~ 0+ log(n/2), dep_tree_metric_seqs[[3]]))
coef(lin_model)[[1]]
coef(nls(d~(n/2)^b, data=dep_tree_metric_seqs[[3]], start=list(b=coef(lin_model)[[1]]), trace=TRUE))[[1]]
```

```{R}
a_initial = 4
b_initial = 4
nonlinear_model <- nls(
  d~a*n^b,
  data=dep_tree_metric_seqs[[3]],
  start=list(a=a_initial, b=b_initial),
  trace=TRUE
)
```
